{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "60d6cc56_7c177818",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1005967
      },
      "writtenOn": "2022-03-09T19:03:29Z",
      "side": 1,
      "message": "My only concern is that with this we have diverging symbolization paths for tombstones vs logcat.",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d242996d_4cc1142c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2024-03-15T23:52:09Z",
      "side": 1,
      "message": "Rebased and moved to r.android.com/3005886",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcbfa44e_dc49fe12",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1005967
      },
      "writtenOn": "2022-03-09T19:03:29Z",
      "side": 1,
      "message": "Do you see this used outside of a lunch environment? llvm-symbolized in ubuntu is usually named \"llvm-symbolizer-\u003cversion\u003e\", and in the NDK context the tool would need to do something special to find the binary, too.",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e450199c_281a9065",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-09T19:29:58Z",
      "side": 1,
      "message": "Yes, the goal is that app developers would be able to use this with symbol servers. I imagine this will require some enhancements to find llvm-symbolizer in the NDK. For now I\u0027m manually adding it to $PATH. It wouldn\u0027t necessarily work to use a distro\u0027s copy of llvm-symbolizer because it may not support symbol servers (either because it isn\u0027t new enough or wasn\u0027t linked with libcurl).\n\nOf course the other route would be to link against the symbolizer library in the LLVM prebuilts. It doesn\u0027t look like we have any other platform binaries that link against those prebuilts so this may require some work on the build files. +srhines who may have opinions on this.",
      "parentUuid": "bcbfa44e_dc49fe12",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f180916_d4e71b22",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2022-03-09T20:21:42Z",
      "side": 1,
      "message": "We currently don\u0027t have anything in the platform linking against LLVM libraries like that. In fact, we don\u0027t provide device versions of any non-runtime libraries at all. I think I\u0027d prefer that we not start doing so for just this feature, especially since it is only needed for debugging, and thus less helpful for regular users (while increasing device image sizes and complexity).",
      "parentUuid": "e450199c_281a9065",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b60de8a_6402cd62",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-09T20:53:20Z",
      "side": 1,
      "message": "Stephen, the goal would be to link against LLVM libraries only on the host, not on the device. I see that we\u0027re already building a prebuilt library for the host (e.g. prebuilts/clang/host/linux-x86/clang-r445002/lib64/libLLVM-14git.so), so I was imagining that we might be able to link against that.",
      "parentUuid": "1f180916_d4e71b22",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca94b986_c309ee0f",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2022-03-10T01:54:41Z",
      "side": 1,
      "message": "Oh I missed that aspect, because I assumed that debuggerd was running on the device too. In that case, it should be possible to build a host-based tool similar to what already exists in https://android-build.googleplex.com/builds/branches/aosp-clang-tools/grid?. https://cs.android.com/search?q\u003dllvm-build-host-tools-defaults\u0026ss\u003dandroid%2Fplatform%2Fsuperproject is the relevant search for how those components are linking against a specific prebuilt LLVM. We don\u0027t allow direct linking against libLLVM.so* in the platform itself today.",
      "parentUuid": "4b60de8a_6402cd62",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f23438c2_aa0aa692",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-03-10T02:01:36Z",
      "side": 1,
      "message": "\u003e Do you see this used outside of a lunch environment? llvm-symbolized in ubuntu is usually named \"llvm-symbolizer-\u003cversion\u003e\", and in the NDK context the tool would need to do something special to find the binary, too.\n\n+danalbert for (a) the NDK view but also (b) whether there\u0027s someone we should talk to in Studio (because i think they have some kind of symbolization stuff in Studio, though i only [think i] know that because i\u0027ve heard users complain about it?).",
      "parentUuid": "ca94b986_c309ee0f",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1402e788_b06d8054",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-10T22:38:55Z",
      "side": 1,
      "message": "\u003e Oh I missed that aspect, because I assumed that debuggerd was running on the device too. In that case, it should be possible to build a host-based tool\n\nAh, I could have sworn that we had something like that but I couldn\u0027t find it. So I can set LLVM_BUILD_HOST_TOOLS\u003dtrue to rebuild the existing tools. The build process seems a bit broken though:\n\n$ out.qm/host/linux-x86/bin/versioner\nout.qm/host/linux-x86/bin/versioner: error while loading shared libraries: libclang-cpp.so.14git: cannot open shared object file: No such file or directory\n\nWorked around with some symlinks:\n\nln -s libclang-cpp_host.so out.qm/host/linux-x86/lib64/libclang-cpp.so.14git\nln -s libc++.so out.qm/host/linux-x86/lib64/libc++.so.1\n\nAccording to a quick scan of the symbols in libclang-cpp.so it looks like it\u0027s missing the symbolizer library. I wonder whether we should be linking \"everything\" into libclang-cpp, and then potentially stop shipping libLLVM since it would be subsumed by libclang-cpp.",
      "parentUuid": "f23438c2_aa0aa692",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b25ba42c_17c848d3",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2022-03-10T23:41:04Z",
      "side": 1,
      "message": "a: Seems pretty likely. Longer term I suspect this could replace ndk-stack entirely? We could wrap this in a python program that sets up PATH if needed. Just linking to it would make that unnecessary, and it sounds like it\u0027s doable?\n\nb: I\u0027ve reached out to jomof to figure out who that might be. If they don\u0027t have it now, that\u0027d be a good bug to fix.",
      "parentUuid": "1402e788_b06d8054",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdc9a203_c5cfe9d5",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-03-10T23:48:17Z",
      "side": 1,
      "message": "(for reference, https://issuetracker.google.com/issues/161939822#comment4 was the most recent complaint i\u0027ve heard about Studio\u0027s implementation, though i don\u0027t know enough to know what\u0027s different about the alternative mentioned there...)",
      "parentUuid": "b25ba42c_17c848d3",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c069ac6b_2cacbb0e",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2022-03-10T23:49:33Z",
      "side": 1,
      "message": "b: emrekultursay would be the one to talk to.",
      "parentUuid": "b25ba42c_17c848d3",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f7e7f2b_8e71cb72",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2022-03-11T04:18:50Z",
      "side": 1,
      "message": "http://b/150809112 is where we add libclang-cpp.so from upstream, but I also recall that we\u0027ve struggled a lot with upstream\u0027s definition of \"everything\". As for versioner, etc., those tools are merely built in that branch, and then checked in as prebuilts. I don\u0027t think anyone runs them from the out/ directory.",
      "parentUuid": "c069ac6b_2cacbb0e",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1d8acc3_7fb257f1",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-14T22:36:48Z",
      "side": 1,
      "message": "Oh, I hadn\u0027t realised that libclang-cpp was now upstream. That would seem to make it more difficult to change what is included.\n\nI wonder what you think about going back to having the build files live downstream since it seems difficult to have something that pleases everyone. The choice of which libraries to include depends to some extent on the downstream tools that link against it and that\u0027s going to be different for everyone.\n\nBy the way, why do we check in those tools as prebuilts? It seems like they could be built in the same way as other host tools, modulo the soname issues that I discovered. If the concern is decoupling the LLVM version used by the compiler from that used by the tools, then it seems like it could be addressed by having the two version numbers be independent in the build system (LLVM_BINDGEN_PREBUILTS_VERSION is prior art).\n\nAt the same time, I don\u0027t think we should block landing this tool on this issue. I would propose that the first version of this tool can do the textual communication with llvm-symbolizer. This would at least allow it to be used in lunched environments. Then it can be changed to link against libclang-cpp (or something else) once this issue gets resolved.",
      "parentUuid": "4f7e7f2b_8e71cb72",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa2ff828_42c6bac8",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2022-03-15T00:08:52Z",
      "side": 1,
      "message": "\u003e Oh, I hadn\u0027t realised that libclang-cpp was now upstream. That would seem to make it more difficult to change what is included.\n\u003e \n\u003e I wonder what you think about going back to having the build files live downstream since it seems difficult to have something that pleases everyone. The choice of which libraries to include depends to some extent on the downstream tools that link against it and that\u0027s going to be different for everyone.\n\nWe\u0027re trying to not diverge from upstream LLVM at all anymore, so perhaps the better solution is to ensure that something like libclang-cpp is actually a full set of functionality, and not some reduced subset. It might be better to influence upstream to make this library complete enough to build all the other LLVM tools with. IMO it seems weird to provide such a library that isn\u0027t even powerful/thorough enough for \"in-tree\" users.\n\n\u003e \n\u003e By the way, why do we check in those tools as prebuilts? It seems like they could be built in the same way as other host tools, modulo the soname issues that I discovered. If the concern is decoupling the LLVM version used by the compiler from that used by the tools, then it seems like it could be addressed by having the two version numbers be independent in the build system (LLVM_BINDGEN_PREBUILTS_VERSION is prior art).\n\nhttps://android.googlesource.com/platform/prebuilts/clang-tools/ is indeed where they live as prebuilts (both darwin and linux versions of the tools, although perhaps the darwin ones are obsolete now.\n\n\u003e \n\u003e At the same time, I don\u0027t think we should block landing this tool on this issue. I would propose that the first version of this tool can do the textual communication with llvm-symbolizer. This would at least allow it to be used in lunched environments. Then it can be changed to link against libclang-cpp (or something else) once this issue gets resolved.\n\nAgreed that nothing should be blocked here on improvements.",
      "parentUuid": "f1d8acc3_7fb257f1",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0025c5a4_70736e84",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-15T01:21:12Z",
      "side": 1,
      "message": "\u003e We\u0027re trying to not diverge from upstream LLVM at all anymore, so perhaps the better solution is to ensure that something like libclang-cpp is actually a full set of functionality, and not some reduced subset. It might be better to influence upstream to make this library complete enough to build all the other LLVM tools with. IMO it seems weird to provide such a library that isn\u0027t even powerful/thorough enough for \"in-tree\" users.\n\nI guess my point was that one person\u0027s \"full set of functionality\" is another\u0027s \"useless bloat\".\n\nMaybe one idea would be to make the list of projects linked into libLLVM.so configurable? So the default would just be llvm but you could also have it be llvm + clang + clang-tools-extra (or just llvm + clang if you don\u0027t care about the tools). Then the in-tree tools in your selected projects would dynamically link against libLLVM instead of being statically linked, and you could dynamically link against it from out of tree as well.\n\nIt looks like there\u0027s something like that already with LLVM_DYLIB_COMPONENTS but that only covers LLVM components.\n\n\u003e https://android.googlesource.com/platform/prebuilts/clang-tools/ is indeed where they live as prebuilts (both darwin and linux versions of the tools, although perhaps the darwin ones are obsolete now.\n\nI was more asking *why* they are prebuilts. If we can have them be built from source like the other host tools then I think that would simplify how they are developed.",
      "parentUuid": "fa2ff828_42c6bac8",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b373d304_48f2b025",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2022-03-15T01:38:14Z",
      "side": 1,
      "message": "\u003e I guess my point was that one person\u0027s \"full set of functionality\" is another\u0027s \"useless bloat\".\n\nI guess I don\u0027t see how something that is intended to provide full Clang functionality to other users could be considered \"bloat\". Restricting it to what\u0027s currently used doesn\u0027t seem downstream-developer-friendly. I could also make the point that anyone concerned with that level of bloat should probably be building their own stripped-down components instead (much like old LLVM\u0027s on the Android device).\n\n\u003e \n\u003e Maybe one idea would be to make the list of projects linked into libLLVM.so configurable? So the default would just be llvm but you could also have it be llvm + clang + clang-tools-extra (or just llvm + clang if you don\u0027t care about the tools). Then the in-tree tools in your selected projects would dynamically link against libLLVM instead of being statically linked, and you could dynamically link against it from out of tree as well.\n\u003e \n\u003e It looks like there\u0027s something like that already with LLVM_DYLIB_COMPONENTS but that only covers LLVM components.\n\nPerhaps. It might be interesting to see what other upstream folks (especially those with other downstream tools) think about providing broader functionality. It\u0027s weird to me that we can\u0027t make the case for \"`llvm-symbolizer` and other utilities should be able to be built dynamically linked to reduce total size\".\n\n\u003e \n\u003e \u003e https://android.googlesource.com/platform/prebuilts/clang-tools/ is indeed where they live as prebuilts (both darwin and linux versions of the tools, although perhaps the darwin ones are obsolete now.\n\u003e \n\u003e I was more asking *why* they are prebuilts. If we can have them be built from source like the other host tools then I think that would simplify how they are developed.\n\nThey are prebuilts because the Clang/LLVM C++ APIs they depend on are unstable. If we had to build these as part of the platform, that means \"we\" (toolchain folks) are now responsible for updating everyone else\u0027s downstream tool sources (many of which have no tests). By decoupling the toolchain they build against, we can ensure that the platform toolchain (and NDK toolchain, and kernel toolchain, ...) can keep flowing along without other teams serving as an unnecessary blocker.",
      "parentUuid": "0025c5a4_70736e84",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da1186e9_df7d250c",
        "filename": "debuggerd/libdebuggerd/tombstone_symbolize.cpp",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2022-03-15T02:09:04Z",
      "side": 1,
      "message": "\u003e I guess I don\u0027t see how something that is intended to provide full Clang functionality to other users could be considered \"bloat\". Restricting it to what\u0027s currently used doesn\u0027t seem downstream-developer-friendly. I could also make the point that anyone concerned with that level of bloat should probably be building their own stripped-down components instead (much like old LLVM\u0027s on the Android device).\n\nI agree that the default should be to provide everything in the project\u0027s lib directory if you\u0027ve opted to include that project in libLLVM. We can let developers contribute more customizations if they want.\n\n\u003e Perhaps. It might be interesting to see what other upstream folks (especially those with other downstream tools) think about providing broader functionality. It\u0027s weird to me that we can\u0027t make the case for \" llvm-symbolizer  and other utilities should be able to be built dynamically linked to reduce total size\".\n\nIt looks like it\u0027s possible to dynamically link the utilities that only use LLVM libraries against libLLVM.so by using LLVM_LINK_DYLIB, but this doesn\u0027t affect Clang tools as far as I\u0027m aware. It would be good to have an upstream solution for shipping both LLVM and Clang tools without shipping duplicate code. One upstream solution that\u0027s being worked on is a \"busybox\" for the LLVM tools (https://reviews.llvm.org/D109977) but this appears to only cover LLVM and not Clang or out-of-tree tools.\n\n\u003e They are prebuilts because the Clang/LLVM C++ APIs they depend on are unstable. If we had to build these as part of the platform, that means \"we\" (toolchain folks) are now responsible for updating everyone else\u0027s downstream tool sources (many of which have no tests). By decoupling the toolchain they build against, we can ensure that the platform toolchain (and NDK toolchain, and kernel toolchain, ...) can keep flowing along without other teams serving as an unnecessary blocker.\n\nRight, I thought it was something like that. But can\u0027t it be solved by making the toolchain version number independent of the tools version number, as I mentioned previously? The idea would be that when you upgrade the toolchain used to build the platform from version X to version Y by changing the value of ClangDefaultVersion in build/soong/cc/config/global.go, the tools would continue to link against version X because that version number would be specified in some other variable (similar to bindgenClangVersion in build/soong/rust/bindgen.go). And updating that to version Y can be done by a separate team independently of the toolchain upgrade.",
      "parentUuid": "b373d304_48f2b025",
      "revId": "7d5037eb3d2fc98f2cbbd00ba730527eda2c5fb4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}