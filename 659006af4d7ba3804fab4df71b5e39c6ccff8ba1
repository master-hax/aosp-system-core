{
  "comments": [
    {
      "key": {
        "uuid": "8bd3c31c_cf394906",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Is there any particular reason for the selection of 1024?\n\nIt seems more robust to ensure O_CLOEXEC is set on all file descriptors that we care about, and in particular to check /proc/self/fd/ instead of relying on a hard-coded constant.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_3a6cb17b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "This is an arbitrary number selected to hopefully close all of the file descriptors. The point of this isn\u0027t to reimplement O_CLOEXEC, it\u0027s to allow us to log failure and create communication pipes when all of the file descriptors *before* the exec happens. (see the comment at line 162)",
      "parentUuid": "8bd3c31c_cf394906",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_75764a4b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "It seems then that we\u0027d want to look in /proc/self/fd and check our ulimit to see if we need to do this, rather than making assumptions.\n\nIf we\u0027re in a sufficiently weird state that we\u0027ve hit the ulimit for file descriptors, it\u0027s reasonable that we may also be in a sufficiently weird state that they\u0027re all above 1024.",
      "parentUuid": "8bd3c31c_3a6cb17b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bc73767_260e56e3",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T22:41:12Z",
      "side": 1,
      "message": "Actually, it looks like you may just be able to increase the soft limit at runtime.\n\nshell@angler:/ $ ulimit -n\n1024\nshell@angler:/ $ ulimit -nH\n4096",
      "parentUuid": "8bd3c31c_75764a4b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10ad446a_8fd0bd5b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 172,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-16T21:56:02Z",
      "side": 1,
      "message": "Handling this \"properly\" in all cases is pretty painful (and maybe impossible?)\nThings that are annoying:\n  We can\u0027t use opendir because we can\u0027t use malloc, so we\u0027re stuck using getdents directly.\n  If we\u0027re out of file descriptors, we can\u0027t even do that, because we can\u0027t get a directory fd (and chdir + AT_FDCWD doesn\u0027t work with getdents).\n  The hard limit can be lowered, so we might not be able to rely on being able to raise it, or being able to loop to it.\n\nThis is intended to be able to report crashes for apps that run out of file descriptors (because of a leak or whatever), not to be safe against someone screwing with us. If we fail here, the worst thing that can happen should be that the process mysteriously dies with no output.",
      "parentUuid": "2bc73767_260e56e3",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_6f267dd5",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "It\u0027s not clear what this actually does, since any effects will be lost via the exec",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_8faae16b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "It gets passed as an argument to exec.",
      "parentUuid": "8bd3c31c_6f267dd5",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_356cc27b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 198,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8bd3c31c_8faae16b",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_cf2ce9b1",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 227,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "This needs to be done in a loop, checking for the exit status.  For example, a SIGSTOP sent to the child should still cause this wait to exit.  See WIFEXITED.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b97d3c5_f74737ba",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 227,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-16T21:56:02Z",
      "side": 1,
      "message": "Replaced with TEMP_FAILURE_RETRY(waitid(P_PID, forkpid, \u0026foo, WEXITED)\n\n(the WNOHANG was also a bug)",
      "parentUuid": "8bd3c31c_cf2ce9b1",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_af8a4566",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Why are we not just using pthread here?  I\u0027m sure there\u0027s a good reason, it\u0027s just not mentioned.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_ba7fe119",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "See the comment at line 162",
      "parentUuid": "8bd3c31c_af8a4566",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_f5897a0a",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "It\u0027s probably worthwhile to add a line comment that just calls out \"this is basically pthread_create without CLONE_FILES and XYZ\"",
      "parentUuid": "8bd3c31c_ba7fe119",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ab888773_c57aba2b",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 271,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-16T21:56:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8bd3c31c_f5897a0a",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_afcb25ab",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 341,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "Why are we doing all of this manually instead of using pthread?\n\nPresumably, it\u0027s to limit the size of the stack and ensure it\u0027s bounded by guard pages on either side.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_0fac11d4",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why we\u0027re skipping over 0x10 bytes at the base of the stack.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_9a94dd1d",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "To satisfy ABI requirements on stack alignment",
      "parentUuid": "8bd3c31c_0fac11d4",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_f5a25a82",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "0xABCDE000 is sufficiently aligned as 0xABCDE010.  There shouldn\u0027t be a need to skip over 16 bytes, unless there\u0027s code that does something silly like dereferencing sp.  Stack frame allocation usually decrements SP before storing.",
      "parentUuid": "8bd3c31c_9a94dd1d",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_b504527e",
        "filename": "debuggerd/handler/debuggerd_handler.cpp",
        "patchSetId": 14
      },
      "lineNbr": 346,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-16T21:56:02Z",
      "side": 1,
      "message": "The manpage says that child_stack should point to \"the topmost address of the memory space\", and I misinterpreted that to mean to the greatest address that was in the range. Fixed.",
      "parentUuid": "8bd3c31c_f5a25a82",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_0f2ed1ed",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 79,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "O_CLOEXEC?",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_6fae7d3c",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "This should be atomic, no?",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_7ac8f941",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1079148
      },
      "writtenOn": "2016-11-08T01:07:49Z",
      "side": 1,
      "message": "This process is entirely single threaded, these callbacks happen in a serialized fashion upon input on a socket (or timeout).",
      "parentUuid": "8bd3c31c_6fae7d3c",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_b5da92fc",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 89,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T02:07:01Z",
      "side": 1,
      "message": "Then the name is a bit misleading, no?",
      "parentUuid": "8bd3c31c_7ac8f941",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8bd3c31c_4fd299bb",
        "filename": "debuggerd/tombstoned/tombstoned.cpp",
        "patchSetId": 14
      },
      "lineNbr": 165,
      "author": {
        "id": 1059554
      },
      "writtenOn": "2016-11-08T00:47:45Z",
      "side": 1,
      "message": "There\u0027s a race condition here, if multiple concurrent dumps take the \u0027false\u0027 branch.",
      "revId": "659006af4d7ba3804fab4df71b5e39c6ccff8ba1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}