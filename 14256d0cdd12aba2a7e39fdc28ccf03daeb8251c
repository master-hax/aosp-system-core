{
  "comments": [
    {
      "key": {
        "uuid": "0f823969_7e75bbf8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-02-19T18:31:25Z",
      "side": 1,
      "message": "b/138956784 is probably the relevant bug for this",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 20,
        "endChar": 8
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a72ced9a_40b75be3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 20,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-21T01:20:37Z",
      "side": 1,
      "message": "Thanks.",
      "parentUuid": "0f823969_7e75bbf8",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 20,
        "endChar": 8
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "03a53878_41e6eecd",
        "filename": "libutils/include/utils/RefBase.h",
        "patchSetId": 1
      },
      "lineNbr": 303,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-02-19T17:49:10Z",
      "side": 1,
      "message": "I would weaken to \"should almost always\", since I don\u0027t think we have a good way to do this for Java ownership.",
      "range": {
        "startLine": 303,
        "startChar": 27,
        "endLine": 303,
        "endChar": 31
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "627b614d_883a3124",
        "filename": "libutils/include/utils/RefBase.h",
        "patchSetId": 1
      },
      "lineNbr": 303,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-02-19T18:31:25Z",
      "side": 1,
      "message": "+1, we need the raw pointer methods for JNI. I don\u0027t think there\u0027s any way to avoid that.",
      "parentUuid": "03a53878_41e6eecd",
      "range": {
        "startLine": 303,
        "startChar": 27,
        "endLine": 303,
        "endChar": 31
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "135ad29f_ccb1f0c6",
        "filename": "libutils/include/utils/RefBase.h",
        "patchSetId": 1
      },
      "lineNbr": 303,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-21T01:20:37Z",
      "side": 1,
      "message": "Clarified what I mean here. RefBase types should be use w/ RefBase functions.",
      "parentUuid": "627b614d_883a3124",
      "range": {
        "startLine": 303,
        "startChar": 27,
        "endLine": 303,
        "endChar": 31
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e9b860a_272e3622",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-02-18T22:55:54Z",
      "side": 1,
      "message": "I don\u0027t know how to do this reasonably in C++, but it would be wonderful if we could somehow arrange to do the incStrong on the base object before we ran the rest of the constructor, so that conversions of this to sp\u003c\u003e in the constructor where unconditionally reliable. If we had a different set of constructors that initialized to a one reference count, that could presumably work, but seems messy.",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26c378fd_0391f69c",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-19T00:57:48Z",
      "side": 1,
      "message": "Well, I think here is what we could do (once sp\u003cT\u003e::make is used everywhere):\n- make RefBase constructor call incStrong at the end\n- call decStrong on the sp\u003cT\u003e created here (or avoid the extra incStrong)\n\nHowever, I can\u0027t think of a way to accomplish this until everyone uses this function, yeah.",
      "parentUuid": "5e9b860a_272e3622",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45cb32a6_7830110a",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-02-19T01:36:23Z",
      "side": 1,
      "message": "If we could eventually switch to a model in which the RefBase constructor always initializes the count to 1 rather than (logically) zero, that would be great.\n\nIt occurs to me that one specific reason it\u0027s somewhat hard to get there is that we have a bunch of cases in which RefBase objects are owned by Java objects. (See e.g. SurfaceTexture_setSurfaceTexture.) They\u0027re referenced via a jlong, where we explicitly manage the reference count. That\u0027s going to make it harder to really make new() private. We could probably still have an initial refcount of one, so long as we update all the clients at once.\n\nI guess this could also be recast as sp\u003c\u003e to/from jlong conversions, but that also seems pretty nasty.\n\nDo you understand how much third-party vendor code relies on our current conventions here?",
      "parentUuid": "26c378fd_0391f69c",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e9cbfd45_e0e445fd",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-19T02:31:36Z",
      "side": 1,
      "message": "\u003e Do you understand how much third-party vendor code relies on our current conventions here?\n\nYes. :) And turning this on globally would be super annoying. However, we could:\n- start using sp\u003cT\u003e::make in new code\n- turn it on in AOSP code first (w/ per-directory #define)\n- mark it as [[deprecated]] etc\n\nIf you prefer, I can file a bug to follow some of these things up. Even turning it on in all AOSP code would probably be a super big change. Honestly, we may need support to automatically refactor code first. However, I still consider this patch a step in the right direciton. WDYT?",
      "parentUuid": "45cb32a6_7830110a",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0c4fbb6_957b1347",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-02-19T17:49:10Z",
      "side": 1,
      "message": "Yes, definitely. Maybe add something like the following comment for now:\n\nTODO: Ideally we should find a way to increment the reference count before running the constructor, so that generating an sp\u003c\u003e to this in the constructor is no longer dangerous.",
      "parentUuid": "e9cbfd45_e0e445fd",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc341ad1_923c0144",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-21T01:20:37Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e0c4fbb6_957b1347",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 46
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "535c3656_df9c4b48",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-02-19T18:03:23Z",
      "side": 1,
      "message": "On second thought, can we just do (untested):\n\nsp\u003cT\u003e result();\nresult.m_ptr \u003d other;\nother-\u003eincStrong(result);\nreturn result;\n\nI think that should have the desired effect of avoiding the useless stack pointer check, and would thus immediately give make() users a performance benefit.",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6959995c_c6a5d1db",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-02-19T18:31:25Z",
      "side": 1,
      "message": "There could also just be an sp constructor with a sentinal that bypasses the check, like this mockup did: https://godbolt.org/z/juXIr6 \n\nThis is the route libc++ took for a few things (such as std::in_place to disambiguate constructors for std::optional, std::any, etc...)",
      "parentUuid": "535c3656_df9c4b48",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b763f7cc_faab7211",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-21T01:20:37Z",
      "side": 1,
      "message": "I\u0027ve done Hans suggestion.\n\nActually, I don\u0027t quite see how the check is getting bypassed there. It seems L44 where Foo is allocated, it\u0027s still checking to see if the pointer is on the stack.",
      "parentUuid": "6959995c_c6a5d1db",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e49b346b_e15e7f7a",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-02-21T18:23:37Z",
      "side": 1,
      "message": "L44 is hitting the implicit constructor which should be hitting the pointer-on-stack check. L52 is where the ::make() variant is used with the explicit constructor which isn\u0027t hitting the check.",
      "parentUuid": "b763f7cc_faab7211",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50d2d001_62432508",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-21T18:52:16Z",
      "side": 1,
      "message": "Ah, I was confused because Foo::ref was elided.\n\nSo, I am still missing the difference between that case and here? Are you saying it should be optimized out here and that we are being over cautious?",
      "parentUuid": "e49b346b_e15e7f7a",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eee5ca9b_ceb092fe",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-02-21T19:10:00Z",
      "side": 1,
      "message": "This approach has the same outcome, hence why I +2\u0027d this. The difference is just in where the bypass is being done. With the approach I posted above the check is being bypassed in sp\u0027s constructor, keeping construction \"atomic\" and keeps the raw pointer \u0026 ref internal to the instance. This approach puts the job of constructing sp into this static method instead.\n\nIt\u0027s the same resulting assembly, it\u0027s just a difference in where you want the code itself to live. In the constructor or in this static helper method.",
      "parentUuid": "50d2d001_62432508",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c75ac37_49d319a3",
        "filename": "libutils/include/utils/StrongPointer.h",
        "patchSetId": 1
      },
      "lineNbr": 184,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-02-24T17:03:13Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "eee5ca9b_ceb092fe",
      "range": {
        "startLine": 184,
        "startChar": 4,
        "endLine": 184,
        "endChar": 20
      },
      "revId": "14256d0cdd12aba2a7e39fdc28ccf03daeb8251c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}