{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "94f1e081_05ccbded",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 35,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "nit: mixing snake case in camel case repository (everywhere)",
      "range": {
        "startLine": 35,
        "startChar": 26,
        "endLine": 35,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "840f1947_85711f3b",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 58,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "gRefDeletedLock, but do consider \u0027std::atomic\u003cbool\u003e\u0027 for this kind of thing",
      "range": {
        "startLine": 58,
        "startChar": 7,
        "endLine": 58,
        "endChar": 13
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "811b2949_c8008294",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "gRefDeleted",
      "range": {
        "startLine": 59,
        "startChar": 5,
        "endLine": 59,
        "endChar": 15
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aede6130_b5dc1a82",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this should no longer be needed right, since these reflect the underlying stores, but strong_weak/weak_count you have reflect API usages, right? (especially since strong_count/weak_count can be zero, I\u0027m not sure what these would do)",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0dbeefba_4dcc473b",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-17T23:54:52Z",
      "side": 1,
      "message": "There\u0027s a LOG_ALWAYS_FATAL_IF in decStrong that will completely crash the fuzzer if decStrong is called with only one remaining strong reference, same for weak references, which is why I have this check.",
      "parentUuid": "aede6130_b5dc1a82",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2791c49_5053e569",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T00:04:01Z",
      "side": 1,
      "message": "this should be if the strong count was 0 or very very big (it\u0027s trying to detect underflow). Note fetch_sub is returning the value of the ref count before the subtraction is applied",
      "parentUuid": "0dbeefba_4dcc473b",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1399b73c_65a05a4e",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-18T00:13:47Z",
      "side": 1,
      "message": "So I guess I\u0027m a little confused about how that works. I see the call to removeStrongRef, then the count is set to mStrong.fetch_sub (so I\u0027m guessing this is the strong count minus 1?), then that value is run through BAD_STRONG. If anything it seems like that logic should trigger when the strong count is 1 or less, which seems to be the behavior I was encountering (thus the strong_count - 1 check)",
      "parentUuid": "c2791c49_5053e569",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "678f0f14_6d2b9874",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 76,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T01:06:17Z",
      "side": 1,
      "message": "\u003e #define BAD_STRONG(c) \\\n\u003e         ((c) \u003d\u003d 0 || ((c) \u0026 (~(MAX_COUNT | INITIAL_STRONG_VALUE))) !\u003d 0)\n\u003e ...\n\u003e void RefBase::decStrong(const void* id) const\n\u003e {\n\u003e ...\n\u003e     const int32_t c \u003d refs-\u003emStrong.fetch_sub(1, std::memory_order_release);\n\u003e ...\n\u003e     LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), \"decStrong() called on %p too many times\",\n\u003e             refs);\n\nHere is the code from RefBase.cpp. If mStrong was 1, then c will be 1, and BAD_STRONG(1) is false, so those won\u0027t be a fatal error (it\u0027ll go on to call onLastStrongRef).",
      "parentUuid": "1399b73c_65a05a4e",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 76,
        "endChar": 1
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a36e1ecc_aa7aa711",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "nit: this is not a recursive mutex, but L137 could take it if it erroneously calls ~RefBaseSubclass. prefer to only hold lock when it is needed, for L134",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f01dfbf_a7bebed3",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-17T23:54:52Z",
      "side": 1,
      "message": "We want to avoid referencing it when L137 is called in another thread. The intent behind using a RWLock was so that L137 could take the lock if RefBaseSubclass is destroyed.",
      "parentUuid": "a36e1ecc_aa7aa711",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f3bccdd_59afaa1d",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T00:04:01Z",
      "side": 1,
      "message": "I feel refDeleted isn\u0027t needed here at all actually, since the thread should know whether it can dec/inc this class based on the local strong_count/weak_count only, regardless of what the other threads do, right?",
      "parentUuid": "9f01dfbf_a7bebed3",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b1774ac_658cfda8",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1695385
      },
      "writtenOn": "2020-11-18T00:13:47Z",
      "side": 1,
      "message": "I guess you\u0027re right actually. As long as this thread\u0027s strong/weak count are greater than zero the object should exist. Same goes for decrementing strong/weak at the end.",
      "parentUuid": "8f3bccdd_59afaa1d",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a1565a2_fb69d5a6",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-18T01:06:17Z",
      "side": 1,
      "message": "Yeah - then also make sure to store global weakref_type* getWeakRefs so that you can dec weak on this, if the RefBase object is already destroyed (instead of having to dereference ref-\u003egetWeakRefs..)",
      "parentUuid": "5b1774ac_658cfda8",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 133,
        "endChar": 39
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3062e259_84adcf59",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 142,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "unnecessary check, and L147, this is never set to nullptr",
      "range": {
        "startLine": 142,
        "startChar": 11,
        "endLine": 142,
        "endChar": 26
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf4ed78c_a76596e6",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 151,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this still leaks weak refs, should decrement all of the weak refs first (or hold onto getWeakRefs), and then decrement the strong refs, which could cause the object to get deleted.\n\nYou can check, but I would expect that L149 always gets hit?",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 151,
        "endChar": 9
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9797fea_351ad343",
        "filename": "libutils/RefBase_fuzz.cpp",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-17T23:12:50Z",
      "side": 1,
      "message": "this should be a fuzzer error, right?",
      "range": {
        "startLine": 182,
        "startChar": 0,
        "endLine": 185,
        "endChar": 5
      },
      "revId": "771418df6b80944926be4c7bfb39aa4b1b97e490",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}